// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: certificate_queries.sql

package certs

import (
	"context"
	"database/sql"
)

const createCertificate = `-- name: CreateCertificate :one
INSERT INTO certificate(user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality,
                        subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number,
                        not_before, not_after, requested_server)
VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
RETURNING pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server
`

type CreateCertificateParams struct {
	UserEmail                 interface{}
	SubjectCommonName         sql.NullString
	SubjectOrganization       interface{}
	SubjectOrganizationalUnit interface{}
	SubjectCountry            interface{}
	SubjectLocality           interface{}
	SubjectProvince           interface{}
	IssuerCommonName          sql.NullString
	IssuerOrganization        sql.NullString
	IssuerOrganizationalUnit  sql.NullString
	IssuerCountry             sql.NullString
	SerialNumber              sql.NullString
	NotBefore                 sql.NullString
	NotAfter                  sql.NullString
	RequestedServer           interface{}
}

func (q *Queries) CreateCertificate(ctx context.Context, arg CreateCertificateParams) (Certificate, error) {
	row := q.db.QueryRowContext(ctx, createCertificate,
		arg.UserEmail,
		arg.SubjectCommonName,
		arg.SubjectOrganization,
		arg.SubjectOrganizationalUnit,
		arg.SubjectCountry,
		arg.SubjectLocality,
		arg.SubjectProvince,
		arg.IssuerCommonName,
		arg.IssuerOrganization,
		arg.IssuerOrganizationalUnit,
		arg.IssuerCountry,
		arg.SerialNumber,
		arg.NotBefore,
		arg.NotAfter,
		arg.RequestedServer,
	)
	var i Certificate
	err := row.Scan(
		&i.Pk,
		&i.SqlTimeStamp,
		&i.UserEmail,
		&i.SubjectCommonName,
		&i.SubjectOrganization,
		&i.SubjectOrganizationalUnit,
		&i.SubjectCountry,
		&i.SubjectLocality,
		&i.SubjectProvince,
		&i.IssuerCommonName,
		&i.IssuerOrganization,
		&i.IssuerOrganizationalUnit,
		&i.IssuerCountry,
		&i.SerialNumber,
		&i.NotBefore,
		&i.NotAfter,
		&i.RequestedServer,
	)
	return i, err
}

const deleteCertificate = `-- name: DeleteCertificate :exec
DELETE FROM certificate
WHERE pk = ?
`

func (q *Queries) DeleteCertificate(ctx context.Context, pk int64) error {
	_, err := q.db.ExecContext(ctx, deleteCertificate, pk)
	return err
}

const getCertificateFromPK = `-- name: GetCertificateFromPK :one
SELECT pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server FROM certificate
WHERE pk = ? LIMIT 1
`

func (q *Queries) GetCertificateFromPK(ctx context.Context, pk int64) (Certificate, error) {
	row := q.db.QueryRowContext(ctx, getCertificateFromPK, pk)
	var i Certificate
	err := row.Scan(
		&i.Pk,
		&i.SqlTimeStamp,
		&i.UserEmail,
		&i.SubjectCommonName,
		&i.SubjectOrganization,
		&i.SubjectOrganizationalUnit,
		&i.SubjectCountry,
		&i.SubjectLocality,
		&i.SubjectProvince,
		&i.IssuerCommonName,
		&i.IssuerOrganization,
		&i.IssuerOrganizationalUnit,
		&i.IssuerCountry,
		&i.SerialNumber,
		&i.NotBefore,
		&i.NotAfter,
		&i.RequestedServer,
	)
	return i, err
}

const getCertificateFromSubjectCommonName = `-- name: GetCertificateFromSubjectCommonName :one
SELECT pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server FROM certificate
WHERE subject_common_name = ? LIMIT 1
`

func (q *Queries) GetCertificateFromSubjectCommonName(ctx context.Context, subjectCommonName sql.NullString) (Certificate, error) {
	row := q.db.QueryRowContext(ctx, getCertificateFromSubjectCommonName, subjectCommonName)
	var i Certificate
	err := row.Scan(
		&i.Pk,
		&i.SqlTimeStamp,
		&i.UserEmail,
		&i.SubjectCommonName,
		&i.SubjectOrganization,
		&i.SubjectOrganizationalUnit,
		&i.SubjectCountry,
		&i.SubjectLocality,
		&i.SubjectProvince,
		&i.IssuerCommonName,
		&i.IssuerOrganization,
		&i.IssuerOrganizationalUnit,
		&i.IssuerCountry,
		&i.SerialNumber,
		&i.NotBefore,
		&i.NotAfter,
		&i.RequestedServer,
	)
	return i, err
}

const getCertificateFromSubjectCommonNameAndUserEmail = `-- name: GetCertificateFromSubjectCommonNameAndUserEmail :one
SELECT pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server FROM certificate
WHERE subject_common_name = ? AND user_email=? LIMIT 1
`

type GetCertificateFromSubjectCommonNameAndUserEmailParams struct {
	SubjectCommonName sql.NullString
	UserEmail         interface{}
}

func (q *Queries) GetCertificateFromSubjectCommonNameAndUserEmail(ctx context.Context, arg GetCertificateFromSubjectCommonNameAndUserEmailParams) (Certificate, error) {
	row := q.db.QueryRowContext(ctx, getCertificateFromSubjectCommonNameAndUserEmail, arg.SubjectCommonName, arg.UserEmail)
	var i Certificate
	err := row.Scan(
		&i.Pk,
		&i.SqlTimeStamp,
		&i.UserEmail,
		&i.SubjectCommonName,
		&i.SubjectOrganization,
		&i.SubjectOrganizationalUnit,
		&i.SubjectCountry,
		&i.SubjectLocality,
		&i.SubjectProvince,
		&i.IssuerCommonName,
		&i.IssuerOrganization,
		&i.IssuerOrganizationalUnit,
		&i.IssuerCountry,
		&i.SerialNumber,
		&i.NotBefore,
		&i.NotAfter,
		&i.RequestedServer,
	)
	return i, err
}

const getCertificatesFromUserEmail = `-- name: GetCertificatesFromUserEmail :many
SELECT pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server FROM certificate
WHERE user_email=?
ORDER BY sql_time_stamp
`

func (q *Queries) GetCertificatesFromUserEmail(ctx context.Context, userEmail interface{}) ([]Certificate, error) {
	rows, err := q.db.QueryContext(ctx, getCertificatesFromUserEmail, userEmail)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.Pk,
			&i.SqlTimeStamp,
			&i.UserEmail,
			&i.SubjectCommonName,
			&i.SubjectOrganization,
			&i.SubjectOrganizationalUnit,
			&i.SubjectCountry,
			&i.SubjectLocality,
			&i.SubjectProvince,
			&i.IssuerCommonName,
			&i.IssuerOrganization,
			&i.IssuerOrganizationalUnit,
			&i.IssuerCountry,
			&i.SerialNumber,
			&i.NotBefore,
			&i.NotAfter,
			&i.RequestedServer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificates = `-- name: ListCertificates :many
SELECT pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server FROM certificate
ORDER BY subject_common_name
`

func (q *Queries) ListCertificates(ctx context.Context) ([]Certificate, error) {
	rows, err := q.db.QueryContext(ctx, listCertificates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.Pk,
			&i.SqlTimeStamp,
			&i.UserEmail,
			&i.SubjectCommonName,
			&i.SubjectOrganization,
			&i.SubjectOrganizationalUnit,
			&i.SubjectCountry,
			&i.SubjectLocality,
			&i.SubjectProvince,
			&i.IssuerCommonName,
			&i.IssuerOrganization,
			&i.IssuerOrganizationalUnit,
			&i.IssuerCountry,
			&i.SerialNumber,
			&i.NotBefore,
			&i.NotAfter,
			&i.RequestedServer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCertificatesByExpiration = `-- name: ListCertificatesByExpiration :many
SELECT pk, sql_time_stamp, user_email, subject_common_name, subject_organization, subject_organizational_unit, subject_country, subject_locality, subject_province, issuer_common_name, issuer_organization, issuer_organizational_unit, issuer_country, serial_number, not_before, not_after, requested_server FROM certificate
ORDER BY not_after
`

func (q *Queries) ListCertificatesByExpiration(ctx context.Context) ([]Certificate, error) {
	rows, err := q.db.QueryContext(ctx, listCertificatesByExpiration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Certificate
	for rows.Next() {
		var i Certificate
		if err := rows.Scan(
			&i.Pk,
			&i.SqlTimeStamp,
			&i.UserEmail,
			&i.SubjectCommonName,
			&i.SubjectOrganization,
			&i.SubjectOrganizationalUnit,
			&i.SubjectCountry,
			&i.SubjectLocality,
			&i.SubjectProvince,
			&i.IssuerCommonName,
			&i.IssuerOrganization,
			&i.IssuerOrganizationalUnit,
			&i.IssuerCountry,
			&i.SerialNumber,
			&i.NotBefore,
			&i.NotAfter,
			&i.RequestedServer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCertificate = `-- name: UpdateCertificate :exec
UPDATE certificate
set user_email=?, subject_common_name=?, subject_organization=?, subject_organizational_unit=?, subject_country=?, subject_locality=?, subject_province=?,
    issuer_common_name=?, issuer_country=?, issuer_organization=?, issuer_organizational_unit=?, serial_number=?, not_before=?, not_after=?
WHERE pk = ?
`

type UpdateCertificateParams struct {
	UserEmail                 interface{}
	SubjectCommonName         sql.NullString
	SubjectOrganization       interface{}
	SubjectOrganizationalUnit interface{}
	SubjectCountry            interface{}
	SubjectLocality           interface{}
	SubjectProvince           interface{}
	IssuerCommonName          sql.NullString
	IssuerCountry             sql.NullString
	IssuerOrganization        sql.NullString
	IssuerOrganizationalUnit  sql.NullString
	SerialNumber              sql.NullString
	NotBefore                 sql.NullString
	NotAfter                  sql.NullString
	Pk                        int64
}

func (q *Queries) UpdateCertificate(ctx context.Context, arg UpdateCertificateParams) error {
	_, err := q.db.ExecContext(ctx, updateCertificate,
		arg.UserEmail,
		arg.SubjectCommonName,
		arg.SubjectOrganization,
		arg.SubjectOrganizationalUnit,
		arg.SubjectCountry,
		arg.SubjectLocality,
		arg.SubjectProvince,
		arg.IssuerCommonName,
		arg.IssuerCountry,
		arg.IssuerOrganization,
		arg.IssuerOrganizationalUnit,
		arg.SerialNumber,
		arg.NotBefore,
		arg.NotAfter,
		arg.Pk,
	)
	return err
}
